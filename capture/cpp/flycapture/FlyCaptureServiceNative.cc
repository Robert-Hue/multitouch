/* DO NOT EDIT THIS FILE - it is machine generated */
#include <map>
#include <jni.h>
#include <pgrflycapture.h>

#define _MAX_CAMS       32    

#ifdef __cplusplus
extern "C" {
#endif

typedef std::map<FlyCaptureCameraSerialNumber, FlyCaptureContext> Connections;
static Connections connections;

//typedef enum {
//    FORMAT_Y_8,
//    FORMAT_Y_16,
//    FORMAT_YUV411_8,
//    FORMAT_YUV422_8,
//    FORMAT_YUV444_8,
//    FORMAT_RGB_8,
//    FORMAT_RGB_16,
//    
//    FORMAT_UNKOWN
//    
//} Format;
//
//typedef enum {
//    RESOLUTION_160_120,
//    RESOLUTION_320_240,
//    RESOLUTION_640_480,
//    RESOLUTION_800_600,
//    RESOLUTION_1024_768,
//    RESOLUTION_1280_960,
//    RESOLUTION_1600_1200,
//    
//    RESOLUTION_UNKOWN,
//} Resolution;
//
//class VideoMode {
//    Resolution resolution;
//    Format format;
//    
//    VideoMode(FlyCaptureVideoMode mode) {
//        // resolution
//        switch(mode) {
//            case FLYCAPTURE_VIDEOMODE_160x120YUV444:                
//                
//                break;
//            case FLYCAPTURE_VIDEOMODE_320x240YUV444:
//                break;
//            case FLYCAPTURE_VIDEOMODE_640x480YUV411:
//            case FLYCAPTURE_VIDEOMODE_640x480YUV422:
//            case FLYCAPTURE_VIDEOMODE_640x480RGB:
//            case FLYCAPTURE_VIDEOMODE_640x480Y8:
//            case FLYCAPTURE_VIDEOMODE_640x480Y16:
//                break;
//                
//                
//        }
//    }
//};


    
JNIEXPORT jint JNICALL Java_de_telekom_laboratories_capture_spi_FlyCaptureNative_deviceHandles
  (JNIEnv *env, jclass type)
{
    FlyCaptureError   error;
    
    FlyCaptureInfoEx  arInfo[ _MAX_CAMS ];
    unsigned int	     uiSize = _MAX_CAMS;      
    
   if(flycaptureBusEnumerateCamerasEx( arInfo, &uiSize ) != FLYCAPTURE_OK) {
       return (jint) 0L;
   } else {
       return (jint) uiSize;
   }
}
    
JNIEXPORT jlong JNICALL Java_de_telekom_laboratories_capture_spi_FlyCaptureNative_createDeviceHandle
    (JNIEnv *env, jclass type, jint index)
{
    FlyCaptureInfoEx  arInfo[ _MAX_CAMS ];
    unsigned int      uiSize = _MAX_CAMS;          
    
   if(flycaptureBusEnumerateCamerasEx( arInfo, &uiSize ) != FLYCAPTURE_OK) {
       printf("ERROR: flyCapture driver problem!");
       return (jlong) 0L;
   }   
    
   if(index < 0 || index >= uiSize) {
       //printf("ERROR: %d < %d", uiSize, index);
       return (jlong) uiSize;
   }
       
    return (jlong) (arInfo + index)->SerialNumber;
}

JNIEXPORT void JNICALL Java_de_telekom_laboratories_capture_spi_FlyCaptureNative_releaseDeviceHandle
  (JNIEnv *env, jclass type, jlong sNumber)
{
    const FlyCaptureCameraSerialNumber serial = (FlyCaptureCameraSerialNumber) sNumber;
    
    // disconnect devices, if connected
    const Connections::iterator connection = connections.find(serial);
    if(connection != connections.end()) {
        FlyCaptureContext context = connection->second;
        flycaptureStop( context );
        flycaptureDestroyContext( context );        
        connections.erase(serial);
    }
}



JNIEXPORT jboolean JNICALL Java_de_telekom_laboratories_capture_spi_FlyCaptureNative_connect
  (JNIEnv *env, jclass type, jlong sNumber, jobject mode)
{
    const FlyCaptureCameraSerialNumber serial = (FlyCaptureCameraSerialNumber) sNumber;
      
    // allow only conncection per camera
    const Connections::iterator connection = connections.find(serial);
    if(connection != connections.end()) {
        return (jboolean) false;
    }

    FlyCaptureContext context;
    if(flycaptureCreateContext( &context ) != FLYCAPTURE_OK) {
        return (jboolean) false;
    }
    
    
    
    if(flycaptureInitializeFromSerialNumber(context, serial) != FLYCAPTURE_OK) {
        flycaptureDestroyContext( context );
        return (jboolean) false;
    }
    
    //TODO: ajdust video mode
    int mode;
    for(mode=0; mode<=7; mode++) {
        
       bool		  bAvailable;
       unsigned int	  uiMaxImageSizeCols;
       unsigned int	  uiMaxImageSizeRows;
       unsigned int	  uiUnitSizeHorz;
       unsigned int	  uiUnitSizeVert;
       unsigned int       uiPixelFormats;
       
       const int status = flycaptureStartCustomImage(context, mode, 
                                    &bAvailable,
                                    &uiMaxImageSizeCols,
                                    &uiMaxImageSizeRows,
                                    &uiUnitSizeHorz,
                                    &uiUnitSizeVert,
                                    &uiPixelFormats);
        if(status != FLYCAPTURE_OK) {
            flycaptureDestroyContext( context );
            return (jboolean) false;
        }
        if(!bAvailable) {
            continue;
        }
       
        
       
    }
    
    if(flycaptureStart(context, FLYCAPTURE_VIDEOMODE_ANY, FLYCAPTURE_FRAMERATE_ANY ) != FLYCAPTURE_OK) {        
        flycaptureDestroyContext( context );
        return (jboolean) false;
    }
      
      
    connections[serial] = context;
      
    return (jboolean) true;
}

JNIEXPORT void JNICALL Java_de_telekom_laboratories_capture_spi_FlyCaptureNative_disconnect
  (JNIEnv *env, jclass type, jlong sNumber)
{
    const FlyCaptureCameraSerialNumber serial = (FlyCaptureCameraSerialNumber) sNumber;
    
    // not connected: return
    const Connections::iterator connection = connections.find(serial);
    if(connection == connections.end()) {
        return;
    }

    FlyCaptureContext context = connection->second;
        
    flycaptureStop( context );
    flycaptureDestroyContext( context );
    
    connections.erase(serial);

}

JNIEXPORT jboolean JNICALL Java_de_telekom_laboratories_capture_spi_FlyCaptureNative_capture
  (JNIEnv *env, jclass type, jlong sNumber, jobject buffer)
{
    const FlyCaptureCameraSerialNumber serial = (FlyCaptureCameraSerialNumber) sNumber;
    
    const Connections::iterator connection = connections.find(serial);
    if(connection == connections.end()) {
        return (jboolean) false;
    }

    FlyCaptureContext context = connection->second;    
    
    FlyCaptureImage image;
    memset( &image, 0x0, sizeof( FlyCaptureImage ) );
    if(flycaptureGrabImage2( context, &image ) != FLYCAPTURE_OK) {
       return (jboolean) false;
    }
    
    //TODO:  write to buffer
    
    return (jboolean) true;
   
}

#ifdef __cplusplus
}
#endif
